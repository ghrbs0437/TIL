# 서브클래싱과 서브타이핑

## 소감

## 서론

상속의 용도

1. `타입 계층` 구현
   - 부모 클래스는 자식 클래스의 일반화
   - 자식 클래스는 부모 클래스의 특수화
2. 코드 재사용

상속은 **코드 재사용이 아닌 타입 계층을 구현하는 것**이어야 한다.

동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 `행동 기반`으로 타입 계층을 구성해야 한다.

```
다형성을 확보하기 위해서는 객체의 행동 기반으로 상속을 구성해야 한다.
```

## 타입

타입의 구성요소 3가지

**심볼**

- 타입의 이름

**외연**

- 타입에 속하는 객체들의 집합

**내연**

- 타입의 정의. 타입의 객체(타입의 구성원)이 가지는 공통적인 속성, 행동

### 개념 관점의 타입

- (사람이) 인식하는 객체들에 적용하는 개념이나 아이디어

일반적으로 타입의 인스턴스를 `객체` 라고 부른다.

### 프로그래밍 언어 관점의 타입

- 컴퓨터세상(하드웨어)의 비트 조합에 부여하는 의미와 제약  


이는 두가지를 목적을 위해 사용된다,

1. 타입에 수행될 수 있는 유효한 오퍼레이션의 집합 정의

   ```
   클래스에서 매서드
   ```

2. 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.
   ```
   오퍼레이션 형태(메서드 시그니처)에 의해 예상가능한 동작
   ```

### 객체지향 패러다임 관점의 타입

객체의 타입은 **객체가 수신할 수 있는 메시지의 종류를 정의하는 것**

객체지향 프로그래밍에서, 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것

객체의 타입을 결정하는 것은, 속성이 아닌 `행동`

## 타입 계층

### 타입 사이의 포함관계

다른 타입을 포함하는 타입은 포함되는 타입보다 더 많은 인스턴스를 가진다.

- 포함하는 타입은 외연 관점에서 더 크고, 내연 관점에서 더 일반적이다.
- 즉, 포함하는 타입은 포함되는 타입보다 더 큰 집합이고, 속성이나 행동은 더 범용적(추상적)이다.

포함하는 타입과 포함되는 타입의 관계를 기반으로,  
더 일반적인 타입을 `슈퍼타입`, 더 특수한 타입을 `서브타입` 으로 부를 수 있다.

일반화란 다른 타입을 포함하거나, 내포하는 타입을 식별하는 행위 또는 그 행위의 결과를 의미한다.

- 즉, 다른 타입들을 묶는 집합을 의미한다.

특수화란 다른 타입 안에 포함되거나 내포되는 타입을 식별하는 행위 또는 그 행위의 결과를 의미한다.

- 즉, 특정 집합 하위의 원소를 의미한다.

### 객체지향 프로그래밍과 타입 계층

객체의 타입을 결정하는 것은 퍼블릭 인터페이스

슈퍼타입이란, 서브타입이 정의한 퍼블릭 인터페이스를 일반화 시켜 넓은 의미로 정의한 것

서브타입이란, 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화 시켜 좁은 의미로 정의한 것

## 서브클래싱과 서브타이핑

### 언제 상속을 사용해야 하는가?

상속의 올바른 용도는 타입 계층을 구현하는 것

어떤 조건을 만족시켜야 타입 계층을 위해 사용했다고 할 수 있는가?

- 상속관계가 is-a 관계를 모델링
  - [자식]는 [부모]이다. 즉, 사과는 과일이다 라고 말해도 이상하지 않으면 상속을 사용할 후보로 간주할 수 있다.
- 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가
  - 상속계층을 활용하는 `클라이언트 입장`에서, 부모클래스와 자식클래스의 차이를 몰라야 한다. 즉 `행동 호환`이 가능해야한다.

**행동 호환이 가능한지에 초점을 맞추어, 타입계층을 위한 상속을 사용하라.**

### is- a 관계

is-a 관계는 생각보다 직관을 배신하기 쉽다.

- 펭귄은 새다
- 새는 날 수 있다

펭귄은 분명 새의 일종이지만, 펭귄은 날 수 없다.  
만약 새의 정의에 '날 수 있다'는 행동이 포함된다면, 펭귄은 새의 서브타입이 될 수 없다.

이러한 점을 고려한다면 객체지향의 세상에서 타입계층을 구성할 때 용어의 어휘적인 정의가 아닌 `기대되는 행동`에 따라 타입 계층을 구성해야만 한다.

따라서 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.

만약 '새'에게 기대되는 행동이 울음소리를 내는것 뿐이라면, 펭귄을 '새'의 서브타입으로 간주할 수 있을 것이다.

### 행동 호환성

타입간의 관계에 행동 연관성이 없다면, is-a 관계를 사용하지 말아야 한다. 즉, 타입계층으로 구성해서는 안된다.

여기서 중요한 부분은 행동의 호환 여부를 판단하는 기준은,  
클라이언트의 관점이라는 점이다. 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대하는지가 행동의 호환 여부를 결정짓는다.

```
=>
올바른 타입계층을 구성하기 위해서는 잠재적으로 타입계층을 활용할 클라이언트가,
의존관계를 가지고 있는 특정 객체(타입)에게 기대하는 역할을 고려해야 한다.
```

'펭귄은 새이다' 라는 언어적 정의에 현혹당한 채로, 타입계층을 구성하기 위해서 아래와 같은 3가지 시도를 할 수 있으나, 객체지향 관점에서 모두 잘못된 설계이다.

```java
// 클라이언트는, 새가 날 수 있다는 행동을 기대한다.
public void flyBird(Bird bird){
  bird.fly();
}


// 1.
// 모든 새가 날 수 있다는 클라이언트의 기대를 충족하지 못한다.
public class Penguin extends Bird{
  ...
  @Override
  public void fly(){}
}

// 2.
// 모든 새가 날 수 있다는 클라이언트의 기대를 충족하지 못한다.
// 클라이언트의 입장에서 UnsupportedOperationException 은 기대하지 않은 동작이다.
public class Penguin extends Bird{
  ...
  @Override
  public void fly(){
    throw new UnsupportedOperationException();
  }
}

// 3.
// 개방 폐쇄 원칙 위반
public void flyBird(Bird bird){
  if(!(bird instanceof Penguin)){
    bird.fly();
  }
}

```

### 클라이언트의 기대에 따라 계층 분리하기

클라이언트의 기대에 맞게 상속 계층을 분리하는 것이 유일한 방법이다.

```java

public class Bird{
  ...
}

public class FlyingBird extends Bird{
  public void fly(){
    ...
  }
  ...
}

public class Penguin extends Bird{
  ...
}

// 클라이언트가 날 수 있는 새만 인자로 전달해야 한다는 사실을 명시
public void flyBird(FlyingBird bird){
  bird.fly();
}
```

상속계층을 분리할 때, 위와 같은 접근법 말고 다른방식도 가능하다.  
바로 클라이언트에 따라 인터페이스를 분리하는 것이다. (`합성`)

```java
public class Bird implements Flyer, Walker{
  ...
}

public class Penguin implements Walker{
  ...
}
```

인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의한 영향을 제어하는 설계 원칙을 인터페이스 분리 원칙(ISP) 라고 한다.

### 서브클래싱과 서브 타이핑

- 서브클래스

  - 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우
  - `클래스 상속` 이라고 부른다.
  - 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.

- 서브타이핑
  - 타입 계층을 구성하기 위해 상속을 사용하는 경우
  - `인터페이스 상속`이라고 부른다.
  - 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.

## 리스코프 치환 원칙

**리스코프 치환 원칙**

- 서브타입은 슈퍼타입에 대해 대체 가능해야 한다.
- 클라이언트가 차이점을 인식하지 못한 채, 클래스의 인터페이스를 통해 서브 클래스를 사용할 수 있어야 한다.
- 즉, 객체의 행동호환성을 의미하는 원칙

"정사각형은 직사각형이다"라는 현실세계의 직관적인 명제를 기반으로  
객체지향의 세계에서 정사각형과 직사각형은 슈퍼타입 / 서브타입 관계가 성립할까?

```java
public class Square extends Rectangle{
  public Square(int x, int y, int size){
    super(x,y,size,size);
  }

  @Override
  public void setWidth(int width){
    super.setWidth(width);
    super.setHeight(width);
  }

  @Override
  public void setHeight(int height){
    super.setWidth(height);
    super.setHeight(height);
  }
}

```

```java
public void resize(Rectangle rectangle, int width, int height){
  rectangle.setWidth(width);
  rectangle.setHeight(height);
  assert rectangle.getWidth() == width && rectangle.getHeight() == height;
}
```

위 코드에서, resize의 인자로 Rectangle이 들어오는 경우는 문제가 없으나, Square이 들어오는 경우,

```java
Square Square = new Square(10, 10, 10);
resize(square, 50, 100);
```

이 메서드 실행이 실패할 것이다.

-> 이는 resize의 관점에서, Rectangle이 Square를 대체할 수 없기 때문이다. (기대하는 동작이 다르다)  
Rectangle과 Square의 관계는 서브타이핑 관계가 아닌, 서브클래싱 관계일 뿐이다.

### 클라이언트와 대체 가능성

Square 가 Rectangle을 대체할 수 없는 이유는, 클라이언트의 관점에서 Square와 Rectangle이 다르기 떄문이다.

Rectangle을 사용하는 클라이언트는 Rectangle의 너비와 높이가 다를 수 있다는 가정하에 코드를 개발하나  
Square의 경우 너비와 높이가 항상 같다. 이 때문에 Rectangle을 Square로 대체하는 경우, Rectangle에 대해 세운 가정을 위반할 가능성이 높다.

리스코프 치환 원칙은,

- 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다
- 클라이언트와 격리한 채로, 본 모델을 의미있게 검증하는 것이 불가능하다

는 점을 시사한다.

```
섣부르게 직관에 의한 타입계층을 구성하면 함정에 빠지기 쉽다.
철저하게 타입계층을 사용할 클라이언트의 관점에서 판단해야 올바른 상속계층 구성이 가능하다.
```

### is - a 관계 다시 살펴보기

is - a 관계로 표현된 문장을 볼 때 마다, "클라이언트 입장에서" 라는 말이 빠져있다고 생각하라.  
클라이언트가 기대하는 객체의 행동이 is - a 관계를 결정짓는다.

서브타이핑을 구현하기 위한 상속만 is-a 관계이다.  
서브클래싱을 구현하기 위한 상속은 is-a 관계가 아니다.

### 리스코프 치환 원칙은 유연한 설계의 기반이다

- 의존성 역전 원칙 (DIP)

  - 구체클래스는 모두 추상클래스에 의존한다

- 리스코프 치환 원칙 (LSP)

  - 클라이언트에 대한 영향 없이 서브타입이 슈퍼타입을 대체할 수 있다.

- 개방-폐쇄 원칙 (OCP)
  - 기능 확장을 하며 기존 코드를 수정할 필요가 없다.

리스코프 치환 원칙은 개방 폐쇄 원칙의 전제조건이다.

## 계약에 의한 설계와 서브 타이핑

클라이언트와 서버 사이의 의무와 이익으로 구성된 계약의 관점에서 표현하는것 (부록.A)

**사전조건**

- 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 조건

**사후조건**

- 메서드가 수행된 후, 서버가 클라이언트에게 보장해야하는 조건

**클래스 불변식**

- 메서드 실행 전, 실행 후에 인스턴스가 만족시켜야 하는 조건

### 서브타입과 계약

- 서브타입에 더 강력한 사전조건을 정의할 수 없다
  - 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
- 서브타입에 더 약한 사후조건을 정의할 수 없다.
