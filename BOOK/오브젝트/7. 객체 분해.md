# 객체 분해

## 소감

## 서론

> 기억은 단기 기억과 장기 기억으로 분류할 수 있다.  
> 장기 기억은 직접 접근하는것이 불가능해 단기 기억 영역으로 옮기고 처리해야한다.  
> 단기 기억에 저장할 수 있는 정보의 개수는 5-9개로 적다.  
> 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 경우 문제 해결 능력이 급격히 떨어지는데, 이를 `인지 과부화` 라고 한다.  
> `추상화 (분해)`를 통해 이를 극복할 수 있다.

**추상화**

- 한 번에 다뤄야 하는 문제의 크기를 줄이는 것

## 프로시저 추상화와 데이터 추상화

모든 프로그래밍 패러다임은 `추상화`와 `분해`의 관점에서 설명할 수 있다.

현대 프로그래밍 언어에서, 두가지 중요한 추상화 메커니즘

**프로시저 추상화**

- 프로그램이 어떤 작업을 수행해야 하는가?
  - 이 추상화 방법을 `기능 분해` 라고 한다.

**데이터 추상화**

- 소프트웨어가 무엇을 알아야 하는가..
  - 데이터를 중심으로 `타입 추상화` or `프로시저 추상화`
    - 전자를 추상 `데이터 타입` 후자를 `객체지향` 이라고 함.

```
💬
용어 설명이 잘 와닿지 않는다.
```

> 프로그래밍 언어적인 관점에서 객체지향을 바라보는 일반적 관점은, 데이터 추상화와 프로시저 추상화를 함께 포함한 `클래스`를 이용해 시스템을 분해하는 것

> 전통적 기능분해 방법(프로시저 추상화)에 비해 객체지향이 효과적 분해방법이다.

## 프로시저 추상화와 기능 분해

### 메인 함수로서의 시스템

`프로시저`는 반복적으로 실행되거나 유사하게 실행되는 작업들을 하나의 장소에 모아놓는 기법  
내부 구현을 모르더라도, 인터페이스만 알면 프로시저를 사용가능하기 때문에 일종의 추상화 기법이다.

> 프로시저 중심의 기능분해 관점에서, 시스템(프로그램)은 하나의 커다란 메인함수이다.  
> 이런 전통적 기능 분해 방법은, 하향적 접근(Top-Down) 을 따른다. 이는 최상위 기능에서 점차 작은 기능으로 분해해 나가는 방식을 말한다.

### 급여 관리 시스템

```
급여 = 기본급 - (기본급 * 소득세율)

1.
직원의 급여를 계산한다.

2.
직원의 급여를 계산한다.
  사용자로부터 소득세율을 입력받는다.
  직원의 급여를 계산한다.
  양식에 맞게 결과를 출력한다.

3.
직원의 급여를 계산한다.
  사용자로부터 소득세율을 입력받는다.
    "세율을 입력하세요: "라는 문장을 화면에 출력한다.
    키보드를 통해 세율을 입력받는다.
  직원의 급여를 계산한다.
    전역 변수에 저장된 직원의 기본급 정보를 얻는다.
    급여를 계산한다.
  양식에 맞게 결과를 출력한다,
    "이름 : {직원명}, 급여 : {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.

최상위 기능에서 부터 점차 작은 기능으로 구체화하며 정의
-> 전통적 기능 분해 방식
```

> 기능 분해 방법에서는, **기능을 중심으로 필요한 데이터를 결정**한다.

> 이는 유지보수에 다양한 문제를 야기한다!

```
💬
(3장참고) 기능이 필요한 데이터를 결정한다는 말은, 협력(프로그램의 목적)이 데이터를 결정짓는다는 의미. 강결합을 암시한다!
```

### 급여 관리 시스템 구현

**직원의 급여를 계산한다.**

```Ruby
def main(name)
end
```

직원의 급여를 계산한다.

- **사용자로부터 소득세율을 입력받는다.**
- **직원 급여를 계산한다.**
- **양식에 맞게 결과를 출력한다.**

```Ruby
def main(name)
  taxRate = getTaxRate()
  pay = calculatePayFor(name, taxRate)
  puts(describeResult(name,pay))
end
```

직원의 급여를 계산한다.

- 사용자로부터 소득세율을 입력받는다.
  - **"세율을 입력하세요: "라는 문장을 화면에 출력한다.**
  - **키보드를 통해 세율을 입력받는다.**

```Ruby
def getTaxRate()
  print("세율을 입력하세요: " )
  return gets().chomp().to_f()
end
```

- 직원 급여를 계산한다.
  - **전역 변수에 저장된 직원의 기본급 정보를 얻는다.**
  - **급여를 계산한다.**

```Ruby
$employees = ["직원A", "직원B", "직원C"]
$basePays = [400, 300, 250]


def calculatePayFor(name, taxRate)
  index = $employees.index(name)
  basePay = $basePays[index]
  return basePay - (basePay * taxRate)
end
```

- **양식에 맞게 결과를 출력한다.**
  - **"이름 : {직원명}, 급여 : {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.**

```Ruby
def describeResult(name, pay)
  return "이름 : #{name} , 급여 : #{pay}"
end
```

하향식 기능분해는 시스템을 최상위의 가장 추상적인 메인 함수로 정의하고, 메인 함수를 구현 가능한 수준까지 세부적 단계로 분해하는 방법.

하향식 기능 분해로 설계한 시스템은 메인 함수를 루트로 하는 트리로 표현할 수 있다.

![image](7.%20기능분해%20구조.png)

### 하향식 기능 분해의 문제점

1. 시스템은 하나의 메인 함수로 구성돼 있지 않다.
2. 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.
3. 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
4. 하향식 분해는 너무 이른 시기에 함수들의 **실행 순서를 고정**시키기 때문에, 유연성과 재사용성이 저하된다.
5. 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.

> 설계의 목적은 `변경에 대비`하는 것인데.. 변경이 어렵다.
> `하향식 접근법`은 `하나의 알고리즘`을 구현하거나 `배치 처리`를 구현하기에는 적합하지만, 현대적인 **상호작용 시스템을 개발하는 데는 적합하지 않다**,

```
💬
동시에.. 하향식 접근법은 하나의 알고리즘 (하나의 구현) 을 처리하기 적합하다는 의미로 들린다.
(p.235) 실제로 그렇다.
```

**시스템은 하나의 메인 함수로 구성돼 있지 않다**

- 실제 시스템에 단 한개의 정상(top)이란 존재하지 않는다.

**메인 함수의 빈번한 재설계**

- 실제 시스템은 여러개의 정상으로 구성되기 때문에, 새로운 정상(기능) 이 추가될 때 마다, main 함수의 내부 구현을 수정할 수 밖에 없다.

```
💬
시스템은 한개의 main함수로 동작하기 때문에, 어떤 기능만 수행할지 취사선택할 수 없다. 취사선택 하기위해서는 main 함수를 수정해야한다.
```

**비즈니스 로직과 사용자 인터페이스 결합**

- 하향식 접근법의 결과, 비즈니스 로직과 사용자 인터페이스의 `관심사가 섞여있다`.
  - `급여를 계산` (로직) 한 후 , `결과를 출력` (UI) 한다.
- `관심사의 분리` 라는 설계의 목적을 달성하기 어렵다.

> 비지니스 로직과 사용자 인터페이스가 변경되는 빈도가 다르다. 사용자 인터페이스는 시스템에서 가장 자주 변경되는 부분이다.

**성급하게 결정된 실행 순서**

- 하향식 접근법은 무엇을 해야하는지가 아니라, 어떻게 동작해야 하는지에 집중하게 만든다.
- 하향식 접근법은 함수들의 실행 순서(제어 구조)를 미리 결정한다.
- 하위 함수는 상위 함수보다 구체적으로 `문맥에 종속적`이다.
  - 즉, 재사용성이 떨어진다.

> 함수의 제어 구조는 시스템에서 변경이 잦은 부분이다.
> 핵심은 `무엇을 해야하는지`

```
💬
프로시저 추상화가 무엇을 해야하는지 에서 부터 출발하지 않았나?
```

**데이터 변경으로 인한 파급효과**

- 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다. 결국 시스템 전체 코드를 분석해야한다.

### 언제 하향식 분해가 유용한가?

- 이미 완전히 이해된 사실을 서술할 때

## 모듈

### 정보 은닉과 모듈

> 시스템의 변경을 관리하는 기본적인 전략은 변경되는 부분을 `하나의 구현 단위`로 묶고 인터페이스를 통해 접근하도록 만드는 것  
> 즉, 기능 기반으로 시스템을 분해하는 것이 아니라, `변경에 방향에 맞춰 시스템을 분해`하는 것

**정보 은닉**

- **변경되는 부분**을 **덜 변경되는 인터페이스 뒤로 감춰야 한다** 는 개념
- `시스템을 분할`하는 모듈 분할 `원리`

**모듈**

- `복잡성` 과 `변경 가능성` 을 감춰야 한다.

모듈과 기능 분해는 상호 배타적인 관계가 아니다. _`시스템을 모듈로 분해한 뒤 기능 분해를 적용할 수 있다.`_

### 모듈의 장점과 한계

**장점**

- 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
- 비지니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
  ```
  💬
  책에서는 비지니스 로직과 사용자 인터페이스에 대한 관심사를 언급했지만
  관심사 Layer영역마다 적용할 수 있는 이야기인 것 같다.
  ```
- 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.

> 모듈은 기능이 아닌, 변경의 정도에 따라 시스템을 분해하게 한다. 이를 통해 `높은 응집도` 와 `낮은 결합도` 를 유지한다.

**한계**

- 인스턴스의 개념을 제공하지 않는다.
  - 이를 해결하기 위해 등장한 개념이 `추상 데이터 타입`

## 데이터 추상화와 추상 데이터 타입

### 추상 데이터 타입

> **타입은 저장된 값에 수행될 수 있는 연산의 집합을 결정**하기 때문에, 변수의 값이 어떻게 행동할 것이라는 것을 예측할 수 있게 한다.

> 추상 데이터 타입은 추상 객체의 클래스를 정의한 것으로 `추상 객체에 사용할 수 있는 오퍼레이션`을 이용해 규정된다.  
> 오퍼레이션을 이용해 추상 데이터 타입을 정의할 수 있음을 의미한다.  
> 추상 데이터 객체를 사용할 때, 프로그래머는 객체가 외부에 제공하는 행위에만 관심을 가지며, 세부적인 사항에 대해서는 무시한다.

추상 데이터 타입을 구현하려면, 프로그래밍 언어의 지원이 필요하다.

- 타입 정의를 선언할 수 있어야 한다.
- 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
- 데이터를 외부로부터 보호할 수 있어야 한다.
- 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.

❗ **TMI** 리스코프 치환원칙

- 서브타입은 언제나 기반 타입으로 교체할 수 있어야 한다. (다형성)

## 클래스

### 클래스는 추상 데이터 타입인가?

부분 일치하지만, 동치는 아니다.

> 추상 데이터 타입 개념에는 상속과 다형성이 포함되지 않는다.

- 추상데이터 타입은 `타입`을 추상화
  - 오퍼레이션을 기준으로 타입을 묶는다.
- 클래스는 `절차`를 추상화
  - 타입을 기준으로 오퍼레이션을 묶는다.

```
💬
❓
마치 한개의 추상데이터 타입은 interface의 구현체인 class를 말하는 것으로 느껴진다.

그래서 유사한 느낌으로는
상속 vs 합성인것 같다.
상속을 통한 타입정의 ??에 해당하는 것이 추상데이터 타입.
합성을 통한 타입정의 에 해당하는 것이 클래스..
```

### 추상 데이터 타입에서 클래스로 변경하기

### 변경을 기준으로 선택하라.

> `타입을 기준`으로 `절차를 추상화`하는 것이 객체지향 분해

_인스턴스 변수에 저장된 값을 기반으로, 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 행위_

객체지향에서는 타입 변수를 이용한 조건문을 `다형성`으로 대체한다.

```
❓
instanceof를 쓰는 코드는 객체지향적이지 못한가? 가장 밑단의 코드에서는 instanceof 키워드를 사용할 수 밖에 없다.
```

**개방-폐쇄 원칙**

- 기존 코드에 아무런 영향을 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 특성

일반적으로, 시스템의 변경이 `타입 추가` 에 초점이 맞춰져 있다면, 객체지향이 좋은 설계.
하지만 시스템의 변경이 `오퍼레이션` 추가에 맞춰져 있다면 추상 데이터 타입이 좋은 설계.

### 협력이 중요하다.

이론적 설계는 이번 장에서 설명한 내용대로이지만...

실제 객체를 설계함에 있어 그 무엇보다 중요한 것은 `역할`, `책임`, `협력`

> 타입 계층 안의 절차를 추상화 함에 있어서, `협력` 이라는 문맥 속 `책임` 이라는 관점이 핵심이다.
