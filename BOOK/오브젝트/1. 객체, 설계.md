# 객체, 설계

## 이론 vs 실무

> 실무를 관철한 결과를 바탕으로 이론을 정립하는 것이 최선이다.

## 티켓 판매 애플리케이션 구현하기

>

```java
// 초대장
public class Invitation {
    private LocalDateTime when;
}
```

```java
public class Ticket {
    private Long fee;

    public Long getFee(){
        return fee;
    }
}
```

```java
public class Bag{
    private Long amount;
    private Invitation invitation;
    private Ticket ticket;

    public boolean hasInvitation(){
        return invitation !=null;
    }
    public boolean hasTicket(){
        return ticket !=null;
    }

    public void setTicket(Ticket ticket){
        this.ticket = ticket;
    }

    public void minusAmount(Long amount){
        this.amount -= amount;
    }

    public void plusAmount(Long amount){
        this.amount += amount;
    }

    public Bag(long amount){
        this(null, amount);
    }

    public Bag(Invitation invitaion, long amount){
        this.invitation = invitation;
        this.amount = amount;
    }

}

```

```java
public class Audience {
    private Bag bag;

    public Audience(Bag bag){
        this.bag = bag;
    }

    public Bag getBag(){
        return bag;
    }

}

```

```java
public class TicketOffice{
    private Long amount;
    private List<Ticket> tickets = new ArrayList<>();

    public TicketOffice(Long amount, Ticket ... tickets){
        this.amount = amount;
        this.tickets.addAll(Arrays.asList(tickets));
    }

    public Ticket getTicket(){
        return tickets.remove(0);
    }

    public void minusAmount(Long amount){
        this.amount -= amount;
    }

    public void plusAmount(Long amount){
        this.amount += amount;
    }
}
```

```java
public class TicketSeller{
    private TicketOffice ticketOffice;

    public TicketSeller(TicketOffice ticketOffice){
        this.ticketOffice = ticketOffice;
    }

    public TicketOffice getTicketOffice(){
        return ticketOffice;
    }
}

```

```java
public class Theater{
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller){
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience){
        if(audience.getBag().hasInvitation()){
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        }else{
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}

```

## 무엇이 문제인가

### 모듈

1. 잘 동작해야한다
2. 변경이 용이해야한다
3. 이해하기 쉬워야 한다.

=> 현재 프로그램은 2,3을 만족시키지 못한다.

### 예상을 빗나가는 코드

이해가능한 코드란, **실 동작이 우리의 예상에서 크게 벗어나지 않는 코드**. 그러나, 위의 예제는

1. 우리의 실생활에서 벗어난 방식으로, 상식과 다르게 동작하여 이해하기 어렵다.
2. 시스템 전체의 구조 뿐만 아니라, 세부적인 의존관계를 모두 알아야 하기 때문에 이해하기 어렵다.

### 변경에 취약한 코드

- `지나치게 세부적인 사실에 의존`해서 동작하는 점 때문에, 변경에 취약해진다.
- **객체 사이의 의존성** 은 변경의 영향을 암시
- 의존성이 과한 경우를, `결합도가 높다` 고 말한다.

=> 좋은 설계는 객체 사이의 결합도를 낮춰 변경에 용이하게 만드는 것.

## 설계 개선하기

- 세부적인 사실에 의존하지 않게 하기 위해서, 객체들을 `자율적인 존재`로 만들자.

### 자율성을 높이자

```java
public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller){
        this.ticketSeller = ticketSeller;
    }
}
```

```java


```

```java

```

```java

```

```java

```

```java

```

```java

```

```java

```

```java

```
